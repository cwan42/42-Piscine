Assignment name  : ft_atoi
Expected files   : ft_atoi.c
Allowed functions: None
Write a function that converts the string argument str to an integer (type int)
and returns it.
It works much like the standard atoi(const char *str) function, see the man.
Your function must be declared as follows:
int	ft_atoi(const char *str);

int	ft_atoi(const char *str)
{
	int	res;
	int	sign;

	res = 0;
	sign = 1;
	while (*str == ' ' || (*str >= 9 && *str <= 13))
		str++;
	while (*str == '+' || *str == '-')
	{
		if (*str == '-')
			sign *= -1;
		str++;
	}
	while (*str >= '0' && *str <= '9')
	{
		res = (res * 10) + (*str - '0');
		str++;
	}
	return (res * sign);
}
/*
#include <stdio.h>

int	main(void)
{
	printf("%d\n", ft_atoi("   -+-+12345 +_---xkhj13 312"));
}
*/

Assignment name  : ft_strdup
Expected files   : ft_strdup.c
Allowed functions: malloc
Reproduce the behavior of the function strdup (man strdup).
Your function must be declared as follows:
char    *ft_strdup(char *src);

#include <stdlib.h>

int	ft_strlen(char *str)
{
	int	i;

	i = 0;
	while (str[i])
		i++;
	return (i);
}

char	*ft_strdup(char *src)
{
	char	*str;
	int	i;

	str = malloc(ft_strlen(src) * sizeof(char));
	i = -1;
	while (src[++i])
		str[i] = src[i];
	str[i] ='\0';
	return (str);	
}
/*
#include <stdio.h>

int	main()
{
	printf("%s\n", ft_strdup("Poopalicious rex"));
	return (0);
}
*/

Assignment name  : inter
Expected files   : inter.c
Allowed functions: write
Write a program that takes two strings and displays, without doubles, the
characters that appear in both strings, in the order they appear in the first
one.
The display will be followed by a \n.
If the number of arguments is not 2, the program displays \n.
Examples:
$>./inter "padinton" "paqefwtdjetyiytjneytjoeyjnejeyj" | cat -e
padinto$
$>./inter ddf6vewg64f gtwthgdwthdwfteewhrtag6h4ffdhsd | cat -e
df6ewg4$
$>./inter "rien" "cette phrase ne cache rien" | cat -e
rien$
$>./inter | cat -e
$

#include <unistd.h>

int	inter(char *str, char c, int len)
{
	int	i;

	i = 0;
	while (str[i] && (i < len || len == -1))
		if (str[i++] == c)
			return (1);
	return(0);
}

int	main(int ac, char *av[])
{
	int	i;

	i = 0;
	if (ac == 3)
	{
		while (av[1][i])
		{
			if (!inter(av[1], av[1][i], i) && inter(av[2], av[1][i], -1))
				write(1, &av[1][i], 1);
			i++;
		}
	}
	write(1, "\n", 1);
	return (0);
}

Assignment name  : last_word
Expected files   : last_word.c
Allowed functions: write
Write a program that takes a string and displays its last word followed by a \n.
A word is a section of string delimited by spaces/tabs or by the start/end of
the string.
If the number of parameters is not 1, or there are no words, display a newline.
Example:
$> ./last_word "FOR PONY" | cat -e
PONY$
$> ./last_word "this        ...       is sparta, then again, maybe    not" | cat -e
not$
$> ./last_word "   " | cat -e
$
$> ./last_word "a" "b" | cat -e
$
$> ./last_word "  lorem,ipsum  " | cat -e
lorem,ipsum$
$>

#include <unistd.h>

void	last_word(char *str)
{
	int	i;
	int	j;

	i = 0;
	j = 0;
	while (str[i])
	{
		if (str[i] == ' ' && str[i + 1] >= 33 && str[i + 1] <= 126)
			j = i + 1;
		i++;
	}
	while (str[j] >= 33 && str[j] <= 126)
	{
		write(1, &str[j], 1);
		j++;
	}
}

int	main(int ac, char *av[])
{
	if (ac == 2)
		last_word(av[1]);	
	write(1, "\n", 1);
	return (0);
}

Assignment name  : reverse_bits
Expected files   : reverse_bits.c
Allowed functions:
Write a function that takes a byte, reverses it, bit by bit (like the
example) and returns the result.
Your function must be declared as follows:
unsigned char	reverse_bits(unsigned char octet);
Example:
  1 byte
_____________
 0010  0110
	 ||
	 \/
 0110  0100

unsigned char	reverse_bits(unsigned char octet);
{
	unsigned char	res;
	int	i;

	res = 0;
	i = 8;

	while (i > 0)
	{
		res = res * 2 + (octet % 2);
		octet = octet / 2;
		i==;
	}
	return (res);
}

Assignment name  : swap_bits
Expected files   : swap_bits.c
Allowed functions:
Write a function that takes a byte, swaps its halves (like the example) and
returns the result.
Your function must be declared as follows:
unsigned char	swap_bits(unsigned char octet);
Example:
  1 byte
_____________
 0100 | 0001
     \ /
     / \
 0001 | 0100

unsigned char	swap_bits(unsigned char c)
{
	return ((c >> 4) | (c << 4));
}

Assignment name  : union
Expected files   : union.c
Allowed functions: write
Write a program that takes two strings and displays, without doubles, the
characters that appear in either one of the strings.
The display will be in the order characters appear in the command line, and
will be followed by a \n.
If the number of arguments is not 2, the program displays \n.
Example:
$>./union zpadinton "paqefwtdjetyiytjneytjoeyjnejeyj" | cat -e
zpadintoqefwjy$
$>./union ddf6vewg64f gtwthgdwthdwfteewhrtag6h4ffdhsd | cat -e
df6vewg4thras$
$>./union "rien" "cette phrase ne cache rien" | cat -e
rienct phas$
$>./union | cat -e
$
$>
$>./union "rien" | cat -e
$
$>

#include <unistd.h>

int	checkdub(char *s, int max, char c)
{
	int	i;

	i = -1;
	while (++i < max)
		if (s[i] == c)
			return (0);
	return (1);
}

int	main(int ac, char *av[])
{
	int	i;
	int	j;

	i = -1;
	j = -1;
	if (ac == 3)
	{
		while (av[1][++i])
			if (checkdub(av[1], i, av[1][i]))
				write(1, &av[1][i], 1);
		while (av[2][++j])
			if (checkdub(av[1], i, av[2][j]) && checkdub(av[2], j, av[2][j]))
				write(1, &av[2][j], 1);
	}
	write(1, "\n", 1);
	return (0);
}

Assignment name  : alpha_mirror
Expected files   : alpha_mirror.c
Allowed functions: write
Write a program called alpha_mirror that takes a string and displays this string
after replacing each alphabetical character by the opposite alphabetical
character, followed by a newline.
'a' becomes 'z', 'Z' becomes 'A'
'd' becomes 'w', 'M' becomes 'N'
and so on.
Case is not changed.
If the number of arguments is not 1, display only a newline.
Examples:
$>./alpha_mirror "abc"
zyx
$>./alpha_mirror "My horse is Amazing." | cat -e
Nb slihv rh Znzarmt.$
$>./alpha_mirror | cat -e
$
$>

#include <unistd.h>

int	main(int ac, char *av[])
{
	int	i;
	char	ltr;

	i = -1;
	if (ac == 2)
	{
		while (av[1][++i])
		{
			ltr = av[1][i];
			if (av[1][i] >= 'A' && av[1][i] <= 'Z')
				ltr = 'Z' - av[1][i] + 'A';
			else if (av[1][i] >= 'a' && av[1][i] <= 'z')
				ltr = 'z' - av[1][i] + 'a';
			write(1, &ltr, 1);
		}
	}
	write(1, "\n", 1);
	return (0);
}
